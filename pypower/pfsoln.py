# Copyright (C) 1996-2010 Power System Engineering Research Center
# Copyright (C) 2010 Richard Lincoln
#
# Licensed under the Apache License, Version 2.0 (the "License")
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from numpy import angle, pi, nonzero, conj, zeros, ones, finfo, r_
from scipy.sparse import csr_matrix

from idx_bus import VM, VA, PD, QD
from idx_gen import GEN_BUS, GEN_STATUS, PG, QG, QMIN, QMAX
from idx_brch import F_BUS, T_BUS, BR_STATUS, PF, PT, QF, QT

EPS = finfo(float).eps

def pfsoln(baseMVA, bus0, gen0, branch0, Ybus, Yf, Yt, V, ref, pv, pq):
    """Updates bus, gen, branch data structures to match power flow soln.

    @see: U{http://www.pserc.cornell.edu/matpower/}
    """
    ## initialize return values
    bus     = bus0
    gen     = gen0
    branch  = branch0

    ##----- update bus voltages -----
    bus[:, VM] = abs(V)
    bus[:, VA] = angle(V) * 180 / pi

    ##----- update Qg for all gens and Pg for swing bus -----
    ## generator info
    on = nonzero(gen[:, GEN_STATUS] > 0) ## which generators are on?
    gbus = gen[on, GEN_BUS]              ## what buses are they at?
    refgen = nonzero(gbus == ref)        ## which is(are) the reference gen(s)?

    ## compute total injected bus powers
    Sg = V[gbus] * conj(Ybus[gbus, :] * V)

    ## update Qg for all generators
    gen[:, QG] = zeros(gen.shape[0], 1)                ## zero out all Qg
    gen[on, QG] = Sg.imag * baseMVA + bus[gbus, QD]    ## inj Q + local Qd
    ## ... at this point any buses with more than one generator will have
    ## the total Q dispatch for the bus assigned to each generator. This
    ## must be split between them. We do it first equally, then in proportion
    ## to the reactive range of the generator.

    if len(on) > 1:
        ## build connection matrix, element i, j is 1 if gen on(i) at bus j is ON
        nb = bus.shape[0]
        ngon = on.shape[0]
        Cg = csr_matrix((ones(ngon), (range(ngon), gbus)), (ngon, nb))

        ## divide Qg by number of generators at the bus to distribute equally
        ngg = Cg * sum(Cg).T    ## ngon x 1, number of gens at this gen's bus
        gen[on, QG] = gen[on, QG] / ngg


        ## divide proportionally
        Cmin = csr_matrix((range(ngon), (gbus, gen[on, QMIN])), (ngon, nb))
        Cmax = csr_matrix((range(ngon), (gbus, gen[on, QMAX])), (ngon, nb))
        Qg_tot = Cg.T * gen[on, QG]## nb x 1 vector of total Qg at each bus
        Qg_min = sum(Cmin).T       ## nb x 1 vector of min total Qg at each bus
        Qg_max = sum(Cmax).T       ## nb x 1 vector of max total Qg at each bus
        ## gens at buses with Qg range = 0
        ig = nonzero(Cg * Qg_min == Cg * Qg_max)
        Qg_save = gen[on(ig), QG]
        gen[on, QG] = gen[on, QMIN] + \
            (Cg * ((Qg_tot - Qg_min) / (Qg_max - Qg_min + EPS))) * \
                (gen[on, QMAX] - gen[on, QMIN])    ##    ^ avoid div by 0
        gen[on[ig], QG] = Qg_save  ## (terms are mult by 0 anyway)

    ## update Pg for swing bus
    ## inj P + local Pd
    gen[on[refgen[1]], PG] = Sg[refgen[1]].real * baseMVA + bus[ref, PD]
    if len(refgen) > 1:       ## more than one generator at the ref bus
        ## subtract off what is generated by other gens at this bus
        gen[on[refgen[1]], PG] = \
            gen[on[refgen[1]], PG] - sum(gen[on[refgen[1:len(refgen)]], PG])

    ##----- update/compute branch power flows -----
    out = nonzero(branch[:, BR_STATUS] == 0)      ## out-of-service branches
    br =  nonzero(branch[:, BR_STATUS])           ## in-service branches

    ## complex power at "from" bus
    Sf = V[branch[br, F_BUS]] * conj(Yf[br, :] * V) * baseMVA
    ## complex power injected at "to" bus
    St = V(branch(br, T_BUS)) * conj(Yt[br, :] * V) * baseMVA
    branch[br, r_[PF, QF, PT, QT]] = r_[Sf.real, Sf.imag, St.real, St.imag]
    branch[out, r_[PF, QF, PT, QT]] = zeros((len(out), 4))

    return bus, gen, branch
